{"./":{"url":"./","title":"JavaScript 版本刷题","keywords":"","body":"Leetcode solutions and summarizations! 看左侧栏，开始你的表演！ 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0001._Two_Sum.html":{"url":"0001._Two_Sum.html","title":"0001 Two Sum","keywords":"","body":"001. Two Sum 难度: Easy 刷题内容 原题连接 https://leetcode.com/problems/two-sum 内容描述 Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 解题方案 思路 1 **- 时间复杂度: O(N)**- 空间复杂度: O(N)** 算法来源于知乎文章——趣味算法思想 先定义一个Object类型的数据结构obj，它的key为target - numbers[i]（比如数组第一项为2），value为索引。然后每次都看看obj[numbers[i]] 是否存在，如果存在，那我们就找到了这样的一组数据，返回当前索引以及obj[numbers[i]]。 代码： /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { var obj = {}; for(var i=0; i= 0) { return [obj[item], i] } else { obj[target - item] = i; } } }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0002._Add_Two_Numbers.html":{"url":"0002._Add_Two_Numbers.html","title":"0002 Add Two Numbers","keywords":"","body":"002. Add Two Numbers 难度: Medium 刷题内容 原题连接 https://leetcode.com/problems/add-two-numbers 内容描述 You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8 Explanation: 342 + 465 = 807. 解题方案 思路 1 **- 时间复杂度: O(max(m,n))**- 空间复杂度: O(max(m,n))** /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */ let addTwoNumbers = function (l1,l2) { let result = new ListNode(0), node = result; while(l1 || l2){ let r = node.val, i = (l1 && l1.val) || 0, j = (l2 && l2.val) || 0, sum = r + i + j, m,n; if(sum >= 10){ m = 1; n = sum - 10; }else{ m = 0; n = sum; } l1 = l1 && l1.next; l2 = l2 && l2.next; node.val = n; if(m || l1 || l2){ node.next = new ListNode(m); node = node.next } } return result; }; function ListNode(val) { this.val = val; this.next = null; } 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0003._Longest_Substring_without_Repeating_Characters.html":{"url":"0003._Longest_Substring_without_Repeating_Characters.html","title":"0003 Longest Substring without Repeating Characters","keywords":"","body":"003. Longest Substring Without Repeating Characters 难度: Medium 刷题内容 原题连接 https://leetcode.com/problems/longest-substring-without-repeating-characters/ 内容描述 Given a string, find the length of the longest substring without repeating characters. Example 1: Input: \"abcabcbb\" Output: 3 Explanation: The answer is \"abc\", with the length of 3. Example 2: Input: \"bbbbb\" Output: 1 Explanation: The answer is \"b\", with the length of 1. Example 3: Input: \"pwwkew\" Output: 3 Explanation: The answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring. 解题方案 思路 1 **- 时间复杂度: O(N^2)**- 空间复杂度: O(N)** 暴力解法 代码： /** * @param {string} s * @return {number} */ let lengthOfLongestSubstring = function (s) { let result = 0; for (let i = 0, len = s.length; i 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0007._Reverse_Integer.html":{"url":"0007._Reverse_Integer.html","title":"0007 Reverse Integer","keywords":"","body":"007. Reverse Integer 难度: Easy 刷题内容 原题连接 https://leetcode.com/problems/reverse-integer 内容描述 Given a 32-bit signed integer, reverse digits of an integer. Example 1: Input: 123 Output: 321 Example 2: Input: -123 Output: -321 Example 3: Input: 120 Output: 21 Note: Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. 解题方案 思路 **- 时间复杂度: O(1)**- 空间复杂度: O(N)** 思路：通过将数字转成数组，然后翻转再转回数字 代码： /** * @param {number} x * @return {number} */ var reverse = function(x) { var num = parseInt(x.toString().split('').reverse().join('')) if(num > Math.pow(2, 31)) { return 0 } if(x 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0008._String_to_Integer.html":{"url":"0008._String_to_Integer.html","title":"0008 String to Integer","keywords":"","body":"008. String to Integer (atoi) 难度: Medium 刷题内容 原题连接 https://leetcode.com/problems/string-to-integer-atoi 内容描述 Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note: Only the space character ' ' is considered as whitespace character. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned. Example 1: Input: \"42\" Output: 42 Example 2: Input: \" -42\" Output: -42 Explanation: The first non-whitespace character is '-', which is the minus sign. Then take as many numerical digits as possible, which gets 42. Example 3: Input: \"4193 with words\" Output: 4193 Explanation: Conversion stops at digit '3' as the next character is not a numerical digit. Example 4: Input: \"words and 987\" Output: 0 Explanation: The first non-whitespace character is 'w', which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed. Example 5: Input: \"-91283472332\" Output: -2147483648 Explanation: The number \"-91283472332\" is out of the range of a 32-bit signed integer. Thefore INT_MIN (−231) is returned. 解题方案 思路 1 **- 时间复杂度: O(1)**- 空间复杂度: O(N)** 代码： /** * @param {string} str * @return {number} */ var myAtoi = function(str) { const INT_MAX = 2 ** 31 - 1; const INT_MIN = -(2 ** 31); str = str.match(/^\\s*([-+]?\\d+)/); let strNum = str ? Number(str[0]) : 0; if(strNum INT_MAX){ return INT_MAX }else{ return strNum } }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0009._Palindrome_Number.html":{"url":"0009._Palindrome_Number.html","title":"0009 Palindrome Number","keywords":"","body":"9. Palindrome Number 难度: Easy 刷题内容 原题连接 https://leetcode.com/problems/palindrome-number 内容描述 Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: Input: 121 Output: true Example 2: Input: -121 Output: false Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: Input: 10 Output: false Explanation: Reads 01 from right to left. Therefore it is not a palindrome. Follow up: Coud you solve it without converting the integer to a string? 解题方案 思路 1 **- 时间复杂度: O(log2 N)**- 空间复杂度: O(1)** 不使用字符串,使用除法分别从首尾获得数字，最后对比是否相同 代码： /** * @param {number} x * @return {boolean} */ var isPalindrome = function(x) { if(xreverse){ reverse = reverse*10 +x%10; x = Math.floor(x/10); } return reverse === x||Math.floor(reverse/10) === x; }; 思路 2 **- 时间复杂度: O(N)**- 空间复杂度: O(N)** 转化为字符串，reverse字符串 代码： var isPalindrome = function(x) { return x.toString().split('').reverse().join('')==x.toString()?true:false; }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0011._Container_With_Most_Water.html":{"url":"0011._Container_With_Most_Water.html","title":"0011 Container With Most Water","keywords":"","body":"11. Container With Most Water 难度: Medium 刷题内容 原题连接 https://leetcode.com/problems/container-with-most-water 内容描述 Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Example: Input: [1,8,6,2,5,4,8,3,7] Output: 49 解题方案 对撞指针 **- 时间复杂度: O(N)**- 空间复杂度: O(1)** 从数组两层对向查找，直到找到最大乘积 代码： var maxArea = function (list) { let i = 0,j = list.length -1,result = 0; while(i 暴力解法 **- 时间复杂度: O(N²)**- 空间复杂度: O(1)** 代码 var maxArea = function (list) { let result = 0; for(let i = 0,len = list.length; i 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0012._Integer_To_Roman.html":{"url":"0012._Integer_To_Roman.html","title":"0012 Integer To Roman","keywords":"","body":"12. Integer to Roman 难度: Medium 刷题内容 原题连接 https://leetcode.com/problems/integer-to-roman 内容描述 Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: 3 Output: \"III\" Example 2: Input: 4 Output: \"IV\" Example 3: Input: 9 Output: \"IX\" Example 4: Input: 58 Output: \"LVIII\" Explanation: L = 50, V = 5, III = 3. Example 5: Input: 1994 Output: \"MCMXCIV\" Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. 解题方案 **- 时间复杂度: O(N)**- 空间复杂度: O(1)** 代码： let getMap = function () { return { 1:'I', 4:'IV', 5:'V', 9:'IX', 10:'X', 40:'XL', 50:'L', 90:'XC', 100:'C', 400:'CD', 500:'D', 900:'CM', 1000:'M' }; }; let match = function (result,num) { let obj = getMap(); while (result.num >= num){ let n = parseInt(result.num /num); result.num = result.num % num; result.str = result.str + obj[num].repeat(n); } }; /** * @param {number} num * @return {string} */ var intToRoman = function (num) { if(num 3999) throw Error('error'); let obj = getMap(); if(num in obj) return obj[num]; let result = { str:'', num }; match(result,1000); match(result,900); match(result,500); match(result,400); match(result,100); match(result,90); match(result,50); match(result,40); match(result,10); match(result,9); match(result,5); match(result,4); match(result,1); return result.str; }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0013._Roman_To_Integer.html":{"url":"0013._Roman_To_Integer.html","title":"0013 Roman To Integer","keywords":"","body":"13. Roman to Integer 难度: Easy 刷题内容 原题连接 https://leetcode.com/problems/roman-to-integer 内容描述 Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: \"III\" Output: 3 Example 2: Input: \"IV\" Output: 4 Example 3: Input: \"IX\" Output: 9 Example 4: Input: \"LVIII\" Output: 58 Explanation: L = 50, V= 5, III = 3. Example 5: Input: \"MCMXCIV\" Output: 1994 Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. 解题方案 **- 时间复杂度: O(N)**- 空间复杂度: O(1)** 代码： /** * @param {string} roman * @return {number} */ let romanToInt = function (roman) { let result = 0; let obj = { 'I':1, 'IV':4, 'V':5, 'IX':9, 'X':10, 'XL':40, 'L':50, 'XC':90, 'C':100, 'CD':400, 'D':500, 'CM':900, 'M':1000 }; for(let len = roman.length,i = len -1;i>=0; i--){ if(i - 1 >= 0 && `${roman.charAt(i - 1)}${roman.charAt(i)}` in obj){ result = result + obj[`${roman.charAt(i - 1)}${roman.charAt(i)}`]; i--; }else{ result = result + obj[roman.charAt(i)]; } } return result; }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0014._Longest_Common_Prefix.html":{"url":"0014._Longest_Common_Prefix.html","title":"0014 Longest Common Prefix","keywords":"","body":"014. Longest Common Prefix 难度: Easy 刷题内容 原题连接 https://leetcode.com/problems/two-sum 内容描述 Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\". Example 1: Input: [\"flower\",\"flow\",\"flight\"] Output: \"fl\" Example 2: Input: [\"dog\",\"racecar\",\"car\"] Output: \"\" Explanation: There is no common prefix among the input strings. Note: All given inputs are in lowercase letters a-z. 解题方案 思路 **- 时间复杂度: O(N)**- 空间复杂度: O(N)** 代码： /** * @param {string[]} strs * @return {string} */ let longestCommonPrefix = function(strs) { let firstStr = strs[0]; let result =''; if(!strs.length){ return result; } for (let i = 0; i 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0015._Three_Sum.html":{"url":"0015._Three_Sum.html","title":"0015 Three Sum","keywords":"","body":"015. 3Sum 难度: Medium 刷题内容 原题连接 https://leetcode.com/problems/3sum 内容描述 Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ] 解题方案 思路 **- 时间复杂度: O(N²)**- 空间复杂度: O(N)** 代码： /** * @param {number[]} nums * @return {number[][]} */ let threeSum = function(nums, n = 0) { let result = []; let len = nums.length; if(!len) return result; // 对数组进行排序 nums.sort((a,b)=>a-b); for(let k = 0; k0 && nums[k-1] === nums[k]){ continue; } let target = n - nums[k]; let i = k + 1; let j = len -1; while(i target){ j--; }else{ i++ } } } return result; }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0016._3_Sum_Closest.html":{"url":"0016._3_Sum_Closest.html","title":"0016 3 Sum Closest","keywords":"","body":"016. 3Sum Closest 难度: Medium 刷题内容 原题连接 https://leetcode.com/problems/3sum-closest 内容描述 Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example: Given array nums = [-1, 2, 1, -4], and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 解题方案 思路 **- 时间复杂度: O(N²)**- 空间复杂度: O(N)** 代码： /** * @param {number[]} nums * @param {number} target * @return {number} */ var threeSumClosest = function(nums, target) { let result = Infinity; let len = nums.length; if(len a+b,0); } nums.sort((a,b)=>a-b); for(let k = 0; k0 && nums[k-1] === nums[k]){ continue; } let i = k + 1; let j = len -1; while(i Math.abs(count - target)){ result = count; } if(count > target){ j-- }else{ i ++ } } } return result; }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0017._Letter_Combinations_Of_A_Phone_Number.html":{"url":"0017._Letter_Combinations_Of_A_Phone_Number.html","title":"0017 Letter Combinations Of A Phone Number","keywords":"","body":"017. Letter Combinations of a Phone Number 难度: Medium 刷题内容 原题连接 https://leetcode.com/problems/letter-combinations-of-a-phone-number/ 内容描述 Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example: Input: \"23\" Output: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]. Note: Although the above answer is in lexicographical order, your answer could be in any order you want. 解题方案 递归版本 **- 时间复杂度: O(N²)**- 空间复杂度: O(N)** 代码： /** * 递归函数 * @param digits 传入的数字 * @param index 当前是第几个数字 * @param str 当前已拼装的字符串 * @param list 结果集 */ let helper = function (digits, index, str, list) { let map = { 2: 'abc', 3: 'def', 4: 'ghi', 5: 'jkl', 6: 'mno', 7: 'pqrs', 8: 'tuv', 9: 'wxyz' }; if (str.length === digits.length) { list.push(str); return false; } let strs = map[digits[index]]; for (let i = 0; i 非递归版本 **- 时间复杂度: O(N²)**- 空间复杂度: O(N)** /** * @param {string} digits * @return {string[]} */ let letterCombinations = function (digits) { let map = { 2: 'abc', 3: 'def', 4: 'ghi', 5: 'jkl', 6: 'mno', 7: 'pqrs', 8: 'tuv', 9: 'wxyz' }; let res = []; for(let i = 0,len = digits.length; i 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0019._Remove_Nth_Node_From_End_Of_List.html":{"url":"0019._Remove_Nth_Node_From_End_Of_List.html","title":"0019 Remove Nth Node From End Of List","keywords":"","body":"019. Remove Nth Node From End Of List 难度: Medium 刷题内容 原题连接 https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/ 内容描述 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 给定一个链表: 1->2->3->4->5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1->2->3->5. 说明： 给定的 n 保证是有效的。 解题方案 思路 1 **- 时间复杂度: O(N)**- 空间复杂度: O(N)** 转化为数组，通过数组下标来确定删除的节点 代码： /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @param {number} n * @return {ListNode} */ var removeNthFromEnd = function(head, n) { if (!head || n === 0) { return head; } const list = []; let cur = head; while (cur) { list.push(cur); cur = cur.next; } const index = list.length - n; if (list.length === 1 && n === 1) { return null; } if (index === 0) { return list[1] } else { list[index-1].next = list[index+1]; return list[0]; } }; 思路2 **- 时间复杂度: O(N)**- 空间复杂度: O(1)** 使用快慢指针的方式，先让fast走n步，再让slow开始和fast一起走，当fast走完的时候，就是slow走到了正确的位置。 var removeNthFromEnd = function(head, n) { if (!head || n === 0) { return head; } let dummy = new ListNode(-1); dummy.next = head; let fast = dummy; let slow = dummy; Array.from(({length:n+1})).forEach(() => { fast = fast.next; }) while(fast) { fast = fast.next; slow = slow.next; } slow.next = slow.next.next; return dummy.next; }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0020._Valid_Parentheses.html":{"url":"0020._Valid_Parentheses.html","title":"0020 Valid Parentheses","keywords":"","body":"020. Valid Parentheses 难度: Easy 刷题内容 原题连接 https://leetcode.com/problems/two-sum 内容描述 Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example 1: Input: \"()\" Output: true Example 2: Input: \"()[]{}\" Output: true Example 3: Input: \"(]\" Output: false Example 4: Input: \"([)]\" Output: false Example 5: Input: \"{[]}\" Output: true 解题方案 思路 1 **- 时间复杂度: O(N)**- 空间复杂度: O(N)** 代码： /** * @param {string} s * @return {boolean} */ var isValid = function(s) { if(!s){ return true; } let array = []; for(let i = 0,len = s.length; i 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0021._Merge_Two_Sorted_Lists.html":{"url":"0021._Merge_Two_Sorted_Lists.html","title":"0021 Merge Two Sorted Lists","keywords":"","body":"021. Merge Two Sorted Lists 难度: Easy 原题连接 https://leetcode.com/problems/merge-two-sorted-lists/ 内容描述 Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: Input: 1->2->4, 1->3->4 Output: 1->1->2->3->4->4 解题方案 思路 1 **- 时间复杂度: O(N)**- 空间复杂度: O(N)** 代码： /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */ var mergeTwoLists = function(l1, l2) { if(l2 == null) return l1; if(l1 == null) return l2; if(l1.val 思路 2: 暴力解法 **- 时间复杂度: O(2N)**- 空间复杂度: O(2N)** 由于是有序的链表，所以可以用数组中转的方式。把两个数组全部转成数组，再将两个数组合并再排序，最后再将两个数组转化为链表。 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */ var mergeTwoLists = function(l1, l2) { if (!l1 && !l2) { return null } let array1 = listNodeToArray(l1) let array2 = listNodeToArray(l2) let array = array1.concat(array2) array.sort((a, b) => (a - b)) return arrayToListNode(array) }; function listNodeToArray (head) { let array = [] while (head) { array.push(head.val) head = head.next } return array } function arrayToListNode(array) { if(!array || !array.length) { return null } let node let head = new ListNode(array[0]) let pnode = head for(let i = 1; i 思路 3: 单次循环遍历 **- 时间复杂度: O(N)**- 空间复杂度: O(N)** /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */ let mergeTwoLists = function(l1, l2) { if(!l1 || !l2){ return (l1 || l2) } let result = new ListNode; let preNode = result; while (l1 || l2){ let currentNode = new ListNode; if(!l2){ currentNode.val = l1.val; l1 = l1.next; }else if(!l1){ currentNode.val = l2.val; l2 = l2.next; }else{ if(l1.val 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0022._Generate_Parentheses.html":{"url":"0022._Generate_Parentheses.html","title":"0022 Generate Parentheses","keywords":"","body":"022. generate-parentheses 难度: Medium 刷题内容 原题连接 https://leetcode-cn.com/problems/generate-parentheses/ 内容描述 Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: [ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\" ] 解题方案 **- 时间复杂度: O(2N)**- 空间复杂度: O(N)** 代码： /** * 递归函数 * @param left 剩余的左括号 * @param right 剩余的又括号 * @param str 当前已拼装括号的字符串 * @param list 最终结果集 */ let helper = function (left,right,str,list) { //当前右括号大于左括号 if (left > right){ return ; } //左括号，右括号均无剩余，作为终值填充 if(left === 0 && right === 0){ list.push(str); return ; } //左括号有剩余 if(left > 0){ helper(left - 1,right,str + '(',list); } //右括号有剩余 if(right > 0){ helper(left,right - 1,str + ')',list); } }; /** * @param {number} n * @return {string[]} */ let generateParenthesis = function(n) { let list = []; helper(n,n,'',list); return list; }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0024._Swap_Nodes_In_Pairs.html":{"url":"0024._Swap_Nodes_In_Pairs.html","title":"0024 Swap Nodes In Pairs","keywords":"","body":"0024. Swap Nodes In Pairs 难度: Medium 刷题内容 原题连接 https://leetcode-cn.com/problems/swap-nodes-in-pairs/ 内容描述 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例: 给定 1->2->3->4, 你应该返回 2->1->4->3. 解题方案 思路 1 **- 时间复杂度: O(N)**- 空间复杂度: O(1)** 递归方式：思路主要是每次swapPairs返回的都是替换后的头指针，所以每次只替换两个，然后当前head.next指向的是移动两次指针后的swapParis返回结果 代码： /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {ListNode} */ const swapPairs = function(head) { if (!head || !head.next) { return head; } let root = head.next; head.next = swapPairs(head.next.next); root.next = head; return root; }; 思路 2 **- 时间复杂度: O(N)**- 空间复杂度: O(1)** 这里借鉴了Python的解题思路 /** * @param {ListNode} head * @return {ListNode} */ const swapPairs = function(head) { if (!head || !head.next) { return head; } let tmp = new ListNode(); tmp.next = head; let current = tmp; while (current.next && current.next.next) { let next1 = current.next; let next2 = current.next.next; let next3 = current.next.next.next; current.next = next2; next2.next = next1; next1.next = next3; current = next1; } return tmp.next; }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0027._Remove_Element.html":{"url":"0027._Remove_Element.html","title":"0027 Remove Element","keywords":"","body":"027. Remove Element 难度: Easy 刷题内容 原题连接 https://leetcode.com/problems/remove-element 内容描述 Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn't matter what you leave beyond the new length. Example 1: Given nums = [3,2,2,3], val = 3, Your function should return length = 2, with the first two elements of nums being 2. It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,1,2,2,3,0,4,2], val = 2, Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4. Note that the order of those five elements can be arbitrary. It doesn't matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeElement(nums, val); // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i 解题方案 思路 1 **- 时间复杂度: O(N)**- 空间复杂度: O(1)** 保留两个指针 i 和 j，其中 i 是慢指针，j 是快指针。当 nums[j] 与给定的值相等时，递增 j 以跳过该元素。只要 nums[j] !== val,我们就复制 nums[j] 到 nums[i] 并同时递增两个索引。重复这一过程，直到 j 到达数组的末尾，该数组的新长度为 i。 代码： /** * @param {number[]} nums * @param {number} val * @return {number} */ var removeElement = function (nums,val) { let j = 0; for(let i = 0,len = nums.length; i 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0031._Next_Permutation.html":{"url":"0031._Next_Permutation.html","title":"0031 Next Permutation","keywords":"","body":"031. Next Permutation 难度: Medium 刷题内容 原题连接 https://leetcode.com/problems/next-permutation/submissions/ 内容描述 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1 解题方案 思路 1 **- 时间复杂度: O(N)**- 空间复杂度: O(1)** 下一个排序与当前排序的关系是尽可能多的共用前面的位数 以[1,2,4,6,5,3]为例： 分为三个步骤 从后向前查找，找到第一个升序排列的组合，即[4,6]，保存这个位置2（即4所在的位置） 在这个位置上后面找到一个比他的数字进行调换——5，数组变为[1,2,5,6,4,3]，如果没有找到，则说明数组已经为最大的排列方式，直接翻转即可 对于这个位置后面的数组([6,4,2])进行升序排列，数组变为[1,2,5,3,4,6] 代码： /** * @param {number[]} nums * @return {void} Do not return anything, modify nums in-place instead. */ var nextPermutation = function(nums) { if (!nums || !nums.length || nums.length 0; i--) { if (nums[i-1] index; i--) { if (nums[i] > nums[index]) { [nums[i], nums[index]] = [nums[index], nums[i]] break; } } // step 3: 最大共有位置之后的数据进行升序排列 const afterList = nums.slice(index + 1) afterList.reverse() for (let i = index + 1; i 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0035._Search_Insert_Position.html":{"url":"0035._Search_Insert_Position.html","title":"0035 Search Insert Position","keywords":"","body":"035. Search Insert Position 难度: Easy 刷题内容 原题连接 https://leetcode.com/problems/search-insert-position/ 内容描述 Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Example 1: Input: [1,3,5,6], 5 Output: 2 Example 2: Input: [1,3,5,6], 2 Output: 1 Example 3: Input: [1,3,5,6], 7 Output: 4 Example 4: Input: [1,3,5,6], 0 Output: 0 解题方案 思路 1 **- 时间复杂度: O(logN)**- 空间复杂度: O(N)** 代码： /** * @param {number[]} nums * @param {number} target * @return {number} */ let searchInsert = function(nums, target) { let lo = 0,high = nums.length-1; while(lotarget) high = mid-1; else lo = mid+1; } return lo; }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0054._Spiral_Matrix.html":{"url":"0054._Spiral_Matrix.html","title":"0054 Spiral Matrix","keywords":"","body":"054.Spiral Matrix 难度: Easy 刷题内容 原题连接 https://leetcode.com/problems/search-insert-position/ 内容描述 给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例 1： 输入: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] 输出: [1,2,3,6,9,8,7,4,5] 示例 2： 输入: [ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12] ] 输出: [1,2,3,4,8,12,11,10,9,5,6,7] 解题方案 思路 1 **- 时间复杂度: O(N)**- 空间复杂度: O(N)** 代码： 递归思路： 取矩阵的第一行 将矩阵逆时针反转90° 递归 终止条件： 矩阵为空 => 返回空矩阵 矩阵只剩下一行 => 返回这一行 /** * @param {number[][]} matrix * @return {number[]} */ var spiralOrder = function(matrix) { if (!matrix || !matrix.length) { return matrix } else if (matrix.length === 1 && Array.isArray(matrix[0])) { return matrix[0] } else { return matrix.shift().concat(spiralOrder(rotate(matrix))) } }; var rotate = function(matrix) { if (!matrix || !matrix.length) { return null } let newMatrix = [] let m = matrix[0].length let n = matrix.length for (let y = m - 1; y >= 0; y--) { let newLine = [] for (let x = n - 1; x >= 0; x--) { newLine.unshift(matrix[x][y]) } newMatrix.push(newLine); } return newMatrix; } 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0055._Jump_Game.html":{"url":"0055._Jump_Game.html","title":"0055 Jump Game","keywords":"","body":"0055. Jump Game 难度: Medium 刷题内容 原题连接 https://leetcode-cn.com/problems/jump-game/ 内容描述 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例1: 输入: [2,3,1,1,4] 输出: true 解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。 示例2： 输入: [3,2,1,0,4] 输出: false 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 解题方案 思路 **- 时间复杂度: O(N)**- 空间复杂度: O(1)** 如果数组中没有0，那么结果一定为true reach代表目前能跳到的最远位置（数组下标） 每轮循环，数组下标固定向有移动一位 start代表本轮循环的位置 每轮循环更新一次最远可达的位置——reach，reach的值为当前循环的值+当前的数组下标与之前reach值的最大值 循环终止条件： 当前下标值大于可达最远位置时，代表当前下标永远达到不了 可达最远位置已经大于数组长度，代表已经能跳到最后位置了 代码： /** * @param {number[]} nums * @return {boolean} */ var canJump = function(nums) { let start = 0; let reach = 0; if (nums.every(i => i)) { return true } while (start = nums.length-1; }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0056._Merge_Intervals.html":{"url":"0056._Merge_Intervals.html","title":"0056 Merge Intervals","keywords":"","body":"056. Merge Intervals 难度: Medium 刷题内容 原题连接 https://leetcode-cn.com/problems/merge-intervals/ 内容描述 给出一个区间的集合，请合并所有重叠的区间。 示例 1: 输入: [[1,3],[2,6],[8,10],[15,18]] 输出: [[1,6],[8,10],[15,18]] 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2: 输入: [[1,4],[4,5]] 输出: [[1,5]] 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 解题方案 思路 1 **- 时间复杂度: O(2N)**- 空间复杂度: O(N)** 先对输入进行排序，然后判断是存在间隔 代码： /** * @param {number[][]} intervals * @return {number[][]} */ var merge = function(intervals) { if (!intervals || !intervals.length) { return intervals; } intervals.sort((a, b) => (a[0] - b[0])) return intervals.reduce((acc, [ currentLeft, currentRight ]) => { if (currentLeft > acc[acc.length - 1][1]) { acc.push([ currentLeft, currentRight ]); } else if (currentRight > acc[acc.length - 1][1]){ acc[acc.length - 1][1] = currentRight; } return acc; }, [intervals[0]]); }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0058._Length_of_Last_Word.html":{"url":"0058._Length_of_Last_Word.html","title":"0058 Length of Last Word","keywords":"","body":"58. Length of Last Word 难度: Easy 刷题内容 原题连接 https://leetcode.com/problems/length-of-last-word 内容描述 Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. Example: Input: \"Hello World\" Output: 5 解题方案 思路 1 **- 时间复杂度: O(N)**- 空间复杂度: O(N)** 将数组以空格分割，找到最后一个字符串输出长度 注意以空格结尾以及输入空字符串 代码： /** * @param {string} s * @return {number} */ var lengthOfLastWord = function(s) { var temp = s.split(' ').filter(function (value) { return value!=''; }); return temp.length>0?temp.pop().length:0; }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0061._Rotate_List.html":{"url":"0061._Rotate_List.html","title":"0061 Rotate List","keywords":"","body":"061. Rotate List 难度: Medium 刷题内容 原题连接 https://leetcode-cn.com/problems/rotate-list/ 内容描述 给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 示例 1: 输入: 1->2->3->4->5->NULL, k = 2 输出: 4->5->1->2->3->NULL 解释: 向右旋转 1 步: 5->1->2->3->4->NULL 向右旋转 2 步: 4->5->1->2->3->NULL 示例 2: 输入: 0->1->2->NULL, k = 4 输出: 2->0->1->NULL 解释: 向右旋转 1 步: 2->0->1->NULL 向右旋转 2 步: 1->2->0->NULL 向右旋转 3 步: 0->1->2->NULL 向右旋转 4 步: 2->0->1->NULL 解题方案 思路 1 **- 时间复杂度: O(N)**- 空间复杂度: O(N)** 将链表存储到数组中，再选择数组，然后再将数组转回链表 代码： /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @param {number} k * @return {ListNode} */ var rotateRight = function(head, k) { if (!head || !head.next || k === 0) { return head; } const list = []; let cur = head; while (cur) { list.push(cur) cur = cur.next; } const index = k%list.length; list.unshift(...list.splice(list.length - index, list.length)) list.forEach((node, index) => { if (index 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0062._Unique_Paths.html":{"url":"0062._Unique_Paths.html","title":"0062 Unique Paths","keywords":"","body":"62. Unique Paths 不同路径 难度: Medium 刷题内容 原题连接 https://leetcode-cn.com/problems/unique-paths/ 内容描述 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 说明：m 和 n 的值均不超过 100。 示例 1: 输入: m = 3, n = 2 输出: 3 解释: 从左上角开始，总共有 3 条路径可以到达右下角。 1. 向右 -> 向右 -> 向下 2. 向右 -> 向下 -> 向右 3. 向下 -> 向右 -> 向右 示例 2: 输入: m = 7, n = 3 输出: 28 解题方案 思路 1 排列组合方式 例子中，m=7、n=3，也就是说，可以向右走6步（m-1）和向下走2步（n-2）； 如果用符号→表示向右走，符号↓表示向下走，那么这道题就变成了，(m-1)个→和(n-1)个↓有多少种排列组合方式，也就是最终 计算公式：(m-1 + n-1)! ÷ （(m-1)! × （n-1）!） 自行实现阶乘计算函数——factorial即可 代码： /** * @param {number} m * @param {number} n * @return {number} */ // 为了提高算法效率，利用cache缓存计算结果 let cache = { 1: 1 } var uniquePaths = function(m, n) { return factorial(m + n - 2) / factorial(m - 1) / factorial(n - 1) }; function factorial(num){ if(num 思路 2 模拟矩阵 - 时间复杂度: O(N) - 空间复杂度: O(N) 如果用每个格子上的值表示，当前格子到左上角格子的走法数量的话，那么右下角格子的值就是最终结果，样子如下 | | | | | - | - | - | | 1 | 1 | 1 | | 1 | 2 | 3 | | 1 | 3 | 6 | | 1 | 4 | 10 | | 1 | 5 | 15 | | 1 | 6 | 21 | | 1 | 7 | 28 | 发现规律，每个格子的值等于左侧格子值 + 上方格子值，所以用双层循环绘制表格，再去最后的值即可。 /** * @param {number} m * @param {number} n * @return {number} */ var uniquePaths = function(m, n) { let metrics = []; for (let x = 0; x 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0066._Plus_One.html":{"url":"0066._Plus_One.html","title":"0066 Plus One","keywords":"","body":"66. Plus One 难度: Easy 刷题内容 原题连接 https://leetcode.com/problems/plus-one 内容描述 Given a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. Example 1: Input: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123. Example 2: Input: [4,3,2,1] Output: [4,3,2,2] Explanation: The array represents the integer 4321. 解题方案 思路 1 **- 时间复杂度: O(N)**- 空间复杂度: O(1)** 如果数字小于9则不会发生进位，仅当前位置++即可 因进位和plus one 都是数字加一 数字大于9则进位与初始加一的处理方式一样 代码： /** * @param {number[]} digits * @return {number[]} */ var plusOne = function(digits) { for(var i=digits.length-1;i>=0;i--){ if(digits[i] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0067._Add_Binary.html":{"url":"0067._Add_Binary.html","title":"0067 Add Binary","keywords":"","body":"67. Add Binary 难度: Easy 刷题内容 原题连接 https://leetcode.com/problems/add-binary 内容描述 Given two binary strings, return their sum (also a binary string). The input strings are both non-empty and contains only characters 1 or 0. Example 1: Input: a = \"11\", b = \"1\" Output: \"100\" Example 2: Input: a = \"1010\", b = \"1011\" Output: \"10101\" 解题方案 思路 1 **- 时间复杂度: O(N)**- 空间复杂度: O(N)** 对于每一位数进行加法，如有进位单独计算 注意需使用字符串进行存储，整型无法计算大型数据 代码： /** * @param {string} a * @param {string} b * @return {string} */ var addBinary = function(a, b) { var tempA = a.split(''); var tempB = b.split(''); var result =[]; var aLen=tempA.length,bLen=tempB.length; var carry = 0; while(aLen>0||bLen>0){ var charA=0,charB=0; if(aLen>0) charA = tempA[--aLen]-0; if(bLen>0) charB = tempB[--bLen]-0; var temp = charA + charB + carry; carry = temp>1?1:0; result.unshift(temp%2); } if(carry===1) result.unshift(1); return result.toString().replace(/,/g,''); }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0074._Search_a_2D_Matrix.html":{"url":"0074._Search_a_2D_Matrix.html","title":"0074 Search a 2D Matrix","keywords":"","body":"074. Search a 2D Matrix 难度: Medium 刷题内容 原题连接 https://leetcode.com/problems/search-a-2d-matrix/ 内容描述 Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. Example 1: Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 Output: true Example 2: Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 13 Output: false 解题方案 思路 1 **- 时间复杂度: O(N)**- 空间复杂度: O(N)** 可以将这个二维数组看做一个数组，以二分法查找为最优算法 代码： /** * @param {number[][]} matrix * @param {number} target * @return {boolean} */ var searchMatrix = function(matrix, target) { if(matrix.length===0) return false; var row=0,col=matrix[0].length-1; while(row=0){ if(matrix[row][col]===target) return true; else if(matrix[row][col]>target) col--; else row++; } return false; }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0079._Search_Word.html":{"url":"0079._Search_Word.html","title":"0079 Search Word","keywords":"","body":"0079. Word Seach 难度: Medium 刷题内容 原题连接 https://leetcode-cn.com/problems/word-search/ 内容描述 给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例: board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] 给定 word = \"ABCCED\", 返回 true. 给定 word = \"SEE\", 返回 true. 给定 word = \"ABCB\", 返回 false. 解题方案 思路 **- 时间复杂度: O(?)**- 空间复杂度: O(1)** 这个时间复杂度我不知道如何分析 思路是深度优先搜索 代码： /** * @param {character[][]} board * @param {string} word * @return {boolean} */ var exist = function(board, word) { let height = board.length; let width = board[0].length; let result = false; for(let x = 0; x 0 && board[x-1][y] === word[0] && !positionInList([x-1,y], list)) { const l = [...list] l.push([x-1, y]); result = result || searchDFS(board, [x-1,y], shiftWord(word), l); } // 下 if (x 0 && board[x][y-1] === word[0] && !positionInList([x,y-1], list)) { const l = [...list] l.push([x, y-1]); result = result || searchDFS(board, [x,y-1], shiftWord(word), l); } // 右 if (y (oX === x && oY === y)) } var shiftWord = function (word) { return Array.prototype.slice.call(word, 1).join('') } 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0083._Remove_Duplicates_From_Sorted_List.html":{"url":"0083._Remove_Duplicates_From_Sorted_List.html","title":"0083 Remove Duplicates From Sorted List","keywords":"","body":"083. Remove Duplicates From Sorted List 难度: Easy 刷题内容 原题连接 https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/ 内容描述 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例 1: 输入: 1->1->2 输出: 1->2 示例 2: 输入: 1->1->2->3->3 输出: 1->2->3 解题方案 思路 1 - 时间复杂度: O(N) - 空间复杂度: O(2N) 暴力解法：将链表转化为数组，对数组去重，然后数组转换为链表 执行用时 :100 ms, 在所有 JavaScript 提交中击败了75.87%的用户 内存消耗 :36.7 MB, 在所有 JavaScript 提交中击败了7.05%的用户 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {ListNode} */ /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {ListNode} */ var deleteDuplicates = function(head) { if (!head) { return null } let array = listNodeToArray(head) return arrayToListNode([...new Set(array)]) }; function listNodeToArray (head) { let array = [] while (head) { array.push(head.val) head = head.next } return array } function arrayToListNode(array) { if(!array || !array.length) { return null } let node let head = new ListNode(array[0]) let pnode = head //pnode变量用来保存前一个节点 for(let i = 1; i 思路 2 - 时间复杂度: O(N) - 空间复杂度: O(1) 快慢指针：每次循环，判断当前的值与下一个是否相等，如果相等，快指针(head)向前移动，慢指针（slow）原地不动；如果不等则把下一个节点连接到慢指针后，再将快慢指针都向前移动。 执行用时 :92 ms, 在所有 JavaScript 提交中击败了91.01%的用户 内存消耗 :35.7 MB, 在所有 JavaScript 提交中击败了69.46%的用户 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {ListNode} */ var deleteDuplicates = function(head) { if (!head) { return null } let slow = head let result = slow while (head) { if (head.next && (head.val === head.next.val)) { head = head.next } else { slow.next = head.next slow = slow.next head = head.next } } return result }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0094._Binary_Tree_Inorder_Traversal.html":{"url":"0094._Binary_Tree_Inorder_Traversal.html","title":"0094 Binary Tree Inorder Traversal","keywords":"","body":"094. Binary Tree Inorder Traversal 难度: Medium 刷题内容 原题连接 https://leetcode-cn.com/problems/binary-tree-inorder-traversal/ 内容描述 给定一个二叉树，返回它的中序 遍历。 示例: 输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,3,2] 解题方案 思路 1 迭代 - 时间复杂度: O(3N) - 空间复杂度: O(N) 执行用时 :64 ms, 在所有 JavaScript 提交中击败了97.85%的用户 内存消耗 :33.7 MB, 在所有 JavaScript 提交中击败了34.70%的用户 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {number[]} */ const inorderTraversal = node => { const valueList = [] forEachTree(node) return valueList function forEachTree (node) { if (!node) { return } forEachTree(node.left) valueList.push(node.val) forEachTree(node.right) } } 思路 2 迭代 时间复杂度: O(N²) 空间复杂度: O(N²) 执行用时 :76 ms, 在所有 JavaScript 提交中击败了69.05%的用户 内存消耗 :33.7 MB, 在所有 JavaScript 提交中击败了36.57%的用户 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {number[]} */ const inorderTraversal = (node) => { const valList = [] const stack = [] while (node || stack.length) { if (node) { stack.push(node) node = node.left } else { node = stack.pop() valList.push(node.val) node = node.right } } return valList }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0098._Validate_Binary_Search_Tree.html":{"url":"0098._Validate_Binary_Search_Tree.html","title":"0098 Validate Binary Search Tree","keywords":"","body":"098. Validate Binary Search Tree 难度: Medium 刷题内容 原题连接 https://leetcode.com/problems/validate-binary-search-tree/ 内容描述 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1: 输入: 2 / \\ 1 3 输出: true 示例 2: 输入: 5 / \\ 1 4 / \\ 3 6 输出: false 解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 解题方案 思路 1 **- 时间复杂度: O(2N)**- 空间复杂度: O(2N)** 一个思路简单的算法，二叉搜索树的中序遍历结果是个有序数组。 获取当前二叉树的中序遍历结果数组 判断上步的数组是否是一个有序数组 代码： /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {boolean} */ var isValidBST = function(root) { var list = inorderTraversal(root) var base = list.join(',') return base === [...new Set(list)].sort((a, b) => (a - b)).join(',') }; // 获取中序遍历 var inorderTraversal = function (root) { if (root === null) return [] return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)] }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0100._Same_Tree.html":{"url":"0100._Same_Tree.html","title":"0100 Same Tree","keywords":"","body":"100. Same Tree 难度: Easy 刷题内容 原题连接 https://leetcode-cn.com/problems/same-tree/ 内容描述 给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1: 输入: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3] 输出: true 示例 2: 输入: 1 1 / \\ 2 2 [1,2], [1,null,2] 输出: false 示例 3: 输入: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2] 输出: false 解题方案 思路 1 **- 时间复杂度: O(N)**- 空间复杂度: O(1)** 递归解法 获取当前二叉树的中序遍历结果数组 判断上步的数组是否是一个有序数组 代码： /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} p * @param {TreeNode} q * @return {boolean} */ var isSameTree = function(p, q) { if (p) { return p && !!q && (p.val === q.val) && isSameTree(p.left, q.left) && isSameTree(p.right,q.right) } else { return !q } }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0101._Symmetric_Tree.html":{"url":"0101._Symmetric_Tree.html","title":"0101 Symmetric Tree","keywords":"","body":"101. Symmetric Tree 难度: Easy 刷题内容 原题连接 https://leetcode.com/problems/symmetric-tree/ 内容描述 给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \\ 2 2 / \\ / \\ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \\ 2 2 \\ \\ 3 3 说明: 如果你可以运用递归和迭代两种方法解决这个问题，会很加分。 解题方案 思路 1 **- 时间复杂度: O(N)**- 空间复杂度: O(1)** 递归解法 代码： /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {boolean} */ var isSymmetric = function(root) { if (!root) { return true } return isMirror(root, root) }; function isMirror(t1, t2) { if (t1 == null && t2 == null) return true; if (t1 == null || t2 == null) return false; return (t1.val == t2.val) && isMirror(t1.right, t2.left) && isMirror(t1.left, t2.right); } 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0104._Maximum_Depth_of_Binary_Tree.html":{"url":"0104._Maximum_Depth_of_Binary_Tree.html","title":"0104 Maximum Depth of Binary Tree","keywords":"","body":"104. Maximum Depth of Binary Tree 难度: Easy 刷题内容 原题连接 https://leetcode.com/problems/maximum-depth-of-binary-tree 内容描述 Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 return its depth = 3. 解题方案 思路 1 **- 时间复杂度: O(log2 N)**- 空间复杂度: O(N)** 这道题使用递归进行解决，因为对于树的每一个儿子的处理方法是一致的。 将左儿子和右儿子中最大的数进行返回再加上当前的深度1即可解决。 代码： var maxDepth = function(root) { if(root===null||root === undefined) return 0; return Math.max(maxDepth(root.left),maxDepth(root.right))+1; }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0106._Construct_Binary_Tree_From_Inorder_And_Postorder_Traversal.html":{"url":"0106._Construct_Binary_Tree_From_Inorder_And_Postorder_Traversal.html","title":"0106 Construct Binary Tree From Inorder And Postorder Traversal","keywords":"","body":"106. Construct Binary Tree From Inorder And Postorder Traversal 难度: Medium 刷题内容 原题连接 https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/ 内容描述 根据一棵树的中序遍历与后序遍历构造二叉树。 注意: 你可以假设树中没有重复的元素。 例如，给出 中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 解题方案 思路 1 **- 时间复杂度: O(N)**- 空间复杂度: O(N)** 代码： var buildTree = function(inorder, postorder) { if (!inorder.length || !postorder.length) { return null } let rootVal = postorder[postorder.length - 1] let root = new TreeNode(rootVal) let k = inorder.indexOf(rootVal) root.left = buildTree(inorder.slice(0, k), postorder.slice(0, k)) root.right = buildTree(inorder.slice(k+1), postorder.slice(k, postorder.length - 1)) return root }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0141._Linked_List_Cycle.html":{"url":"0141._Linked_List_Cycle.html","title":"0141 Linked List Cycle","keywords":"","body":"0141. Linked List Cycle 难度: Easy 刷题内容 原题连接 https://leetcode.com/problems/linked-list-cycle/ 内容描述 Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Example 1: Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: Input: head = [1,2], pos = 0 Output: true Explanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: Input: head = [1], pos = -1 Output: false Explanation: There is no cycle in the linked list. Follow up: Can you solve it using O(1) (i.e. constant) memory? 解题方案 思路 1 **- 时间复杂度: O(N)**- 空间复杂度: O(N)** 使用快慢指针的思路进行解题。就像两个运动员在同一个环形赛道上赛跑，如果一个运动员跑的快，一个跑得慢，最后两个运动员一定会相遇。 下面代码中的fast每次会走两步，而slow每次会走一步，如果fast没有next节点，自然没有环；如果fast等于slow说明二者相遇，最终为表明存在环。 执行结果 执行用时 :92 ms, 在所有 JavaScript 提交中击败了94.16%的用户 内存消耗 :36.6 MB, 在所有 JavaScript 提交中击败了51.93% 代码： /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {boolean} */ var hasCycle = function(head) { if (head === null || head.next === null) { return false } let slow = head let fast = head.next while (slow !== fast) { if (fast === null || fast.next === null) { return false } slow = slow.next fast = fast.next.next } return true }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0146._LRU_Cache.html":{"url":"0146._LRU_Cache.html","title":"0146 LRU Cache","keywords":"","body":"0146. LRU Cache 难度: Medium 刷题内容 原题链接 https://leetcode.com/problems/lru-cache/ 内容描述 Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. The cache is initialized with a positive capacity. Follow up: Could you do both operations in O(1) time complexity? Example: LRUCache cache = new LRUCache( 2 /* capacity */ ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // returns 1 cache.put(3, 3); // evicts key 2 cache.get(2); // returns -1 (not found) cache.put(4, 4); // evicts key 1 cache.get(1); // returns -1 (not found) cache.get(3); // returns 3 cache.get(4); // returns 4 解题方案 思路1 **- 时间复杂度: O(1)**- 空间复杂度: O(N)** 这是一道数据结构的考题。 简单的获取和插入，顺序不做考虑，所以数据结构用Object即可。 但是重要的考点——LRU，也就是删除最近没有使用的数据。所以想到用队列存在key列表： 未超过存储上限时，每次put一个新数据时，向队列末尾插入当前key 每次get时，如果key存在，则将对应的key从的队列中，移到对末尾 在超过存储上限时，如进行put操作，则将队列首位删除掉 执行用时 :492 ms, 在所有 JavaScript 提交中击败了35.29%的用户 内存消耗 :59.7 MB, 在所有 JavaScript 提交中击败了16.36%的用户 /** * @param {number} capacity */ var LRUCache = function(capacity) { this.limit = capacity || 2 this.storage = {} this.keyList = [] }; /** * @param {number} key * @return {number} */ LRUCache.prototype.get = function(key) { if (this.storage.hasOwnProperty(key)) { let index = this.keyList.findIndex(k => k === key) this.keyList.splice(index, 1) this.keyList.push(key) return this.storage[key] } else { return -1 } }; /** * @param {number} key * @param {number} value * @return {void} */ LRUCache.prototype.put = function(key, value) { // 判断容量 if (this.keyList.length >= this.limit && !this.storage.hasOwnProperty(key)) { this.deleteLRU() } // 存储数据 this.updateKeyList(key) this.storage[key] = value }; LRUCache.prototype.deleteLRU = function () { delete this.storage[this.keyList.shift()] } LRUCache.prototype.updateKeyList = function (key) { if (this.storage.hasOwnProperty(key)) { var index = this.keyList.findIndex(k => key === k) this.keyList.splice(index, 1) } this.keyList.push(key) } /** * Your LRUCache object will be instantiated and called as such: * var obj = new LRUCache(capacity) * var param_1 = obj.get(key) * obj.put(key,value) */ 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0167._Two_Sum_II_-_Input_array_is_sorted.html":{"url":"0167._Two_Sum_II_-_Input_array_is_sorted.html","title":"0167 Two Sum II - Input array is sorted","keywords":"","body":"167. Two Sum II - Input array is sorted 难度: Easy 刷题内容 原题连接 https://leetcode.com/problems/two-sum-ii-input-array-is-sorted 内容描述 Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Note: Your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. Example: Input: numbers = [2,7,11,15], target = 9 Output: [1,2] Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2. 解题方案 思路 1 **- 时间复杂度: O(log2 N)**- 空间复杂度: O(n)** 使用贪心算法，用左右的数字开始加，如果数字大于目标right--，反之left++ 代码： /** * @param {number[]} numbers * @param {number} target * @return {number[]} */ var twoSum = function(numbers, target) { if(numbers.length===0) return []; var left = 0,right = numbers.length-1; while(right>left){ if(numbers[right]+numbers[left]>target) right--; else if(numbers[right]+numbers[left] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0167._Two_Sum_II_Input_Array_is_Sorted.html":{"url":"0167._Two_Sum_II_Input_Array_is_Sorted.html","title":"0167 Two Sum II Input Array is Sorted","keywords":"","body":"167. Two Sum II - Input array is sorted 难度: Easy 刷题内容 原题连接 https://leetcode.com/problems/two-sum-ii-input-array-is-sorted 内容描述 Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Note: Your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. Example: Input: numbers = [2,7,11,15], target = 9 Output: [1,2] Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2. 解题方案 思路 1 **- 时间复杂度: O(N)**- 空间复杂度: O(N)** 算法来源于知乎文章——趣味算法思想 由于数组是有序的，所以可以从两边向中间逐渐收敛地进行查找，好处在于避免了双重循环 如果最两端的和小于目标数，则可以让左侧下标+1，然后重新进行运算比较 如果最两端的和大于目标数，则可以让右侧下标-1，然后重新进行运算比较 代码： /** * @param {number[]} numbers * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { var number=[]; var left = 0; var right = nums.length - 1 ; while(left target ) { right--; } else { left++; } } }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0171._Excel_Sheet_Column_Number.html":{"url":"0171._Excel_Sheet_Column_Number.html","title":"0171 Excel Sheet Column Number","keywords":"","body":"0171. Excel Sheet Column Number 难度: Easy 刷题内容 原题连接 https://leetcode-cn.com/problems/excel-sheet-column-number/ 内容描述 给定一个Excel表格中的列名称，返回其相应的列序号。 例如， A -> 1 B -> 2 C -> 3 ... Z -> 26 AA -> 27 AB -> 28 ... 示例 1: 输入: \"A\" 输出: 1 示例 2: 输入: \"AB\" 输出: 28 示例 3: 输入: \"ZY\" 输出: 701 解题方案 思路 1 **- 时间复杂度: O(N)**- 空间复杂度: O(1)** 利用parseInt可以按照进制来解析的特性，可以将英文字母轻松转换成数字 代码： /** * @param {string} s * @return {number} */ var titleToNumber = function(s) { if (!s) { return 0 } let list = s.split('') list = list.map((alpha, index) => (parseInt(alpha, 36) - 9) * Math.pow(26, list.length - index - 1)) return list.reduce((acc, cur) => (acc + cur), 0) } 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0179._Largest_Number.html":{"url":"0179._Largest_Number.html","title":"0179 Largest Number","keywords":"","body":"0179. Largest Number 难度: Medium 刷题内容 原题连接 https://leetcode-cn.com/problems/largest-number/ 内容描述 给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。 示例 1: 输入: [10,2] 输出: 210 示例 2: 输入: [3,30,34,5,9] 输出: 9534330 说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数。 解题方案 思路 1 **- 时间复杂度: O(N)**- 空间复杂度: O(1)** 排序时，计算两个数字谁在前面组成的数字比较大即可 代码： /** * @param {number[]} nums * @return {string} */ var largestNumber = function(nums) { if (nums.every(n => !n)) { return '0' } return nums.sort((a, b) => { return Number('' + b + a) - Number('' + a + b) }).join('') }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0203._Remove_Linked_List_Elements.html":{"url":"0203._Remove_Linked_List_Elements.html","title":"0203 Remove Linked List Elements","keywords":"","body":"203. Remove Linked List Elements 难度: Easy 刷题内容 原题连接 https://leetcode-cn.com/problems/remove-linked-list-elements/ 内容描述 删除链表中等于给定值 val 的所有节点。 示例: 输入: 1->2->6->3->4->5->6, val = 6 输出: 1->2->3->4->5 解题方案 思路 1 - 时间复杂度: O(3N) - 空间复杂度: O(2N) 暴力解法： 将链表转化为数组 对数组进行过滤 将过滤后的数组重新转化为数组 执行用时 :160 ms, 在所有 JavaScript 提交中击败了10.71%的用户 内存消耗 :38.4 MB, 在所有 JavaScript 提交中击败了5.13%的用户 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @param {number} val * @return {ListNode} */ var removeElements = function(head, val) { if (!head) { return head } let array = listNodeToArray(head) array = array.filter(i => (i !== val)) return arrayToListNode(array) }; function listNodeToArray (head) { let array = [] while (head) { array.push(head.val) head = head.next } return array } function arrayToListNode(array) { if(!array || !array.length) { return null } let node let head = new ListNode(array[0]) let pnode = head //pnode变量用来保存前一个节点 for(let i = 1; i 思路 2 - 时间复杂度: O(N) - 空间复杂度: O(1) 快慢指针： 快指针(head)每次循环都向前移动一个 慢指针(slow)只有在快指针当前节点的值不等于给定值时，才会向前移动，并在此之前将快指针当前节点指向慢指针的next 执行用时 :108 ms, 在所有 JavaScript 提交中击败了77.37%的用户 内存消耗 :37.9 MB, 在所有 JavaScript 提交中击败了11.11%的用户 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @param {number} val * @return {ListNode} */ var removeElements = function(head, val) { if (!head) { return head } let slow = new ListNode() let result = slow while (head) { if (head.val !== val) { slow.next = head slow = slow.next } else if (!head.next) { slow.next = null } head = head.next } return result.next }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0209._Minimum_Size_Subarray_Sum.html":{"url":"0209._Minimum_Size_Subarray_Sum.html","title":"0209 Minimum Size Subarray Sum","keywords":"","body":"209. Minimum Size Subarray Sum 难度: Medium 刷题内容 原题连接 https://leetcode.com/problems/minimum-size-subarray-sum 内容描述 Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead. Example: Input: s = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: the subarray [4,3] has the minimal length under the problem constraint. 解题方案 思路 1 **- 时间复杂度: O(N)**- 空间复杂度: O(N)** 算法来源于知乎文章——趣味算法思想 这里可以看到由于需要找连续的子数组，所以依旧可以设置两个指针，往同一方向移动。 如果两个指针中间的值加起来>sum的时候，记录此时数组的长度，接着左指针移动，减小sum的值 ； 如果 最后返回最短的长度值。 代码： /** * @param {number} s * @param {number[]} nums * @return {number} */ var minSubArrayLen = function(s, nums) { var left = 0; var right = -1; // right 的起始位置很重要，这里选择-1 [left, right]这个区间刚开始是没有值的 var tmpSum = 0; var minLength; // 循环停止的条件是左指针小于长度 while (left = nums.length -1) { return minLength || 0; } right ++; // 这里tmpSum的计算也很巧妙，直接用累加的方式，节省计算量 tmpSum = tmpSum + nums[right] } else { var tmp = right - left + 1; if(minLength) { if(tmp 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0258._Add_Digits.html":{"url":"0258._Add_Digits.html","title":"0258 Add Digits","keywords":"","body":"258. Add Digits 难度: Easy 刷题内容 原题连接 https://leetcode.com/problems/add-digits 内容描述 Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. Example: Input: 38 Output: 2 Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it. Follow up: Could you do it without any loop/recursion in O(1) runtime? 解题方案 思路 1 **- 时间复杂度: O(1)**- 空间复杂度: O(1)** 原理： 假设输入的数字是一个5位数字num，则num的各位分别为a、b、c、d、e 有如下关系：num = a 10000 + b 1000 + c 100 + d 10 + e 即：num = (a + b + c + d + e) + (a 9999 + b 999 + c 99 + d 9) 因为 a 9999 + b 999 + c 99 + d 9 一定可以被9整除，因此num模除9的结果与 a + b + c + d + e 模除9的结果是一样的。 对数字 a + b + c + d + e 反复执行同类操作，最后的结果就是一个 1-9 的数字加上一串数字，最左边的数字是 1-9 之间的，右侧的数字永远都是可以被9整除的。 这道题最后的目标，就是不断将各位相加，相加到最后，当结果小于10时返回。因为最后结果在1-9之间，得到9之后将不会再对各位进行相加，因此不会出现结果为0的情况。 因为 (x + y) % z = (x % z + y % z) % z，又因为 x % z % z = x % z，因此结果为 (num - 1) % 9 + 1，只模除9一次，并将模除后的结果加一返回。 代码： /** * @param {number} num * @return {number} */ var addDigits = function(num) { if(num==0) return num; if(num%9==0) return 9; else return num%9; }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0347._Top_K_Frequent_Elements.html":{"url":"0347._Top_K_Frequent_Elements.html","title":"0347 Top K Frequent Elements","keywords":"","body":"0347. Top K Frequent Elements 难度: Medium 刷题内容 原题连接 https://leetcode-cn.com/problems/top-k-frequent-elements/ 内容描述 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例 1: 输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2] 示例 2: 输入: nums = [1], k = 1 输出: [1] 解题方案 思路 1 **- 时间复杂度: O(Nk)**- 空间复杂度: O(N)* 利用原生的sort方法， 遍历原有数组，推导出每个数字出现的频率。 根据出现的频率，利用sort进行排序 代码： /** * @param {number[]} nums * @param {number} k * @return {number[]} */ var topKFrequent = function(nums, k) { var list = {} if (nums.length === k) { return nums } while (nums.length) { var num = nums.pop() if (list[num]) { list[num]++ } else { list[num] = 1 } } return Object.keys(list).sort((a, b) => { return list[b] - list[a] }).slice(0, k).map(n => Number(n)) }; 思路 2 **- 时间复杂度: O(Nk)**- 空间复杂度: O(N)* 自行实现的排序方式 遍历原有数组，推导出每个数字出现的频率。 利用快排实现排序 let partion = function(arr, left, right){ let i = left; let j = right; let base = arr[left]; while(i=base.freq && ik-1){ quickSort(arr, left, m-1, k); } } } let Node = function(val, freq){ this.val = val; this.freq = freq; } var topKFrequent = function(nums, k) { let map = {}; nums.forEach(e=>{ if(map[e]){ map[e].freq += 1; }else{ map[e] = new Node(e, 1); } }); let arr = []; for(let i in map){ arr.push(map[i]); } quickSort(arr, 0, arr.length-1, k); let res = []; for(let i=0; i 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0402._Remove_K_Digits.html":{"url":"0402._Remove_K_Digits.html","title":"0402 Remove K Digits","keywords":"","body":"402. Remove K Digits 难度: Medium 刷题内容 原题连接 https://leetcode.com/problems/remove-k-digits 内容描述 Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible. Note: The length of num is less than 10002 and will be ≥ k. The given num does not contain any leading zero. Example 1: Input: num = \"1432219\", k = 3 Output: \"1219\" Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest. Example 2: Input: num = \"10200\", k = 1 Output: \"200\" Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes. Example 3: Input: num = \"10\", k = 2 Output: \"0\" Explanation: Remove all the digits from the number and it is left with nothing which is 0. 解题方案 思路 1 **- 时间复杂度: O(N)**- 空间复杂度: O(N)** 使用栈的思路 如果n是num的长度，我们要去除k个，那么需要剩下n-k个数，定义一个result数组用于保存剩下的字符，与result中最后一个字符相比，比它小， 栈中最后一个字符出栈，该字符进栈，否则该字符直接进栈。值得注意的是在删除k个数之后，若剩下的数前面有0，应该去掉。 代码： /** * @param {string} num * @param {number} k * @return {string} */ var removeKdigits = function(num, k) { let stack = [], numDigits = num.length; for (let i = 0; i 0 && stack.length && stack[stack.length - 1] > num[i]) { stack.pop(); k--; } stack.push(num[i]); } stack = k > 0 ? stack.slice(0, -k) : stack; return stack.join('').replace(/^0+/, '') || '0'; }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0406._Queue_Reconstruction_By_Height.html":{"url":"0406._Queue_Reconstruction_By_Height.html","title":"0406 Queue Reconstruction By Height","keywords":"","body":"406. Queue Reconstruction By Height 难度: medium 刷题内容 原题连接 https://leetcode-cn.com/problems/queue-reconstruction-by-height/ 内容描述 假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。 注意： 总人数少于1100人。 示例 1: 输入: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]] 输出: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 解题方案 思路 1 **- 时间复杂度: O(N²)**- 空间复杂度: O(N)** 贪心算法 思路 个子矮的人的位置不会影响到其他人，他的位置不会影响到其他人。 操作步骤 对人群排序，由高到低，身高相同再由低到高 建立一个空队列 对排序后的人群进行遍历，将当前遍历的人 按照他的索引（n）插入到队列第n的位置 代码： var reconstructQueue = function(people) { people.sort((a, b) => ((b[0] - a[0]) || (a[1] - b[1]))); let queue = []; people.forEach(person => { queue.splice([person[1]], 0, person); }) return queue }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0485._Max_Consecutive_Ones.html":{"url":"0485._Max_Consecutive_Ones.html","title":"0485 Max Consecutive Ones","keywords":"","body":"485. Max Consecutive Ones 难度: Easy 刷题内容 原题连接 https://leetcode.com/problems/max-consecutive-ones 内容描述 Given a binary array, find the maximum number of consecutive 1s in this array. Example 1: Input: [1,1,0,1,1,1] Output: 3 Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. Note: The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000 解题方案 思路 1 **- 时间复杂度: O(N)**- 空间复杂度: O(N)** 使用temp保存每个0之间的差值 找出最大的差值即可 代码： /** * @param {number[]} nums * @return {number} */ var findMaxConsecutiveOnes = function(nums) { var max = 0,temp = 0; for(var i =0;i 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0539._Minimum_Time_Difference.html":{"url":"0539._Minimum_Time_Difference.html","title":"0539 Minimum Time Difference","keywords":"","body":"539. Minimum Time Difference 难度: Medium 刷题内容 原题连接 https://leetcode.com/problems/minimum-time-difference 内容描述 Given a list of 24-hour clock time points in \"Hour:Minutes\" format, find the minimum minutes difference between any two time points in the list. Example 1: Input: [\"23:59\",\"00:00\"] Output: 1 Note: The number of time points in the given list is at least 2 and won't exceed 20000. The input time is legal and ranges from 00:00 to 23:59. 解题方案 思路 1 **- 时间复杂度: O(N)**- 空间复杂度: O(N)** 将所有时间转换成分钟数，然后进行sort排序 计算两个数之间的差值，找出最小差值即可 不要忘记第一个时间与最后一个时间相比较 代码： /** * @param {string[]} timePoints * @return {number} */ var findMinDifference = function(timePoints) { var dayTime = 24*60; var minTime = 24*60; var temp = timePoints.map(function (value) { var t = value.split(':'); return parseInt(t[0])*60+parseInt(t[1]); }); temp.sort(function (a,b) { return a-b; }); for(var i =0;i(dayTime/2)){ diff = Math.abs(temp[f]-(temp[b]+dayTime)); minTime = diff 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0581._Shortest_Unsorted_Continuous_Subarray.html":{"url":"0581._Shortest_Unsorted_Continuous_Subarray.html","title":"0581 Shortest Unsorted Continuous Subarray","keywords":"","body":"581. 最短无序连续子数组 难度: Easy 刷题内容 原题连接 https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/ 内容描述 给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。 你找到的子数组应是最短的，请输出它的长度。 示例1: 输入: [2, 6, 4, 8, 10, 9, 15] 输出: 5 解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。 说明 : 输入的数组长度范围在 [1, 10,000]。 输入的数组可能包含重复元素 ，所以升序的意思是 解题方案 思路 1 **- 时间复杂度: O(1)**- 空间复杂度: O(N)** 省空间的算法，但是耗时间 每次循环，如果当前数组的第一位是最小值，则将其“弹出”；如果最后一位是最大值，则也将其“弹出”；如果以上两种情况都没有，则说明剩下的数组是最短无序连续子数组 代码： /** * @param {number[]} nums * @return {number} */ var findUnsortedSubarray = function(nums) { while (nums.length) { if (nums[0] === Math.min(...nums)) { nums.shift() } else if (nums[nums.length - 1] === Math.max(...nums)) { nums.pop() } else { return nums.length } } return nums.length }; 思路 2 **- 时间复杂度: O(1)**- 空间复杂度: O(2N)** 省时间的算法，但是耗空间 与上面方法比较，不用每次都计算最大值和最小值 var findUnsortedSubarray = function(nums) { const newNums = [...nums] nums.sort((a, b) => (a - b)) let startIndex = 0 let endIndex = 0 // 正向查找 for (let i = 0; i 0; j--) { if (nums[nums.length - 1] === newNums[j]) { nums.pop(); } else { break } } return nums.length; }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0881._Boats_to_Save_People.html":{"url":"0881._Boats_to_Save_People.html","title":"0881 Boats to Save People","keywords":"","body":"881. Boats to Save People 难度: Medium 刷题内容 原题连接 https://leetcode.com/problems/boats-to-save-people 内容描述 The i-th person has weight people[i], and each boat can carry a maximum weight of limit. Each boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most limit. Return the minimum number of boats to carry every given person. (It is guaranteed each person can be carried by a boat.) Example 1: Input: people = [1,2], limit = 3 Output: 1 Explanation: 1 boat (1, 2) Example 2: Input: people = [3,2,2,1], limit = 3 Output: 3 Explanation: 3 boats (1, 2), (2) and (3) Example 3: Input: people = [3,5,3,4], limit = 5 Output: 4 Explanation: 4 boats (3), (3), (4), (5) Note: 1 解题方案 思路 1 **- 时间复杂度: O(N logN)**- 空间复杂度: O(N)** 使用贪心算法，将数组进行排序之后进行处理 代码： /** * @param {number[]} people * @param {number} limit * @return {number} */ var numRescueBoats = function(people, limit) { people.sort(function (a,b) { return a-b }); var num=0; for(var left = 0,right = people.length-1;right-left>=0;right--){ if(people[left]+people[right] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0997._Find_The_Town_Judge.html":{"url":"0997._Find_The_Town_Judge.html","title":"0997 Find The Town Judge","keywords":"","body":"997. Find The Town Judge 难度: Easy 刷题内容 原题连接 https://leetcode-cn.com/problems/find-the-town-judge/ 内容描述 在一个小镇里，按从 1 到 N 标记了 N 个人。传言称，这些人中有一个是小镇上的秘密法官。 如果小镇的法官真的存在，那么： 小镇的法官不相信任何人。 每个人（除了小镇法官外）都信任小镇的法官。 只有一个人同时满足属性 1 和属性 2 。 给定数组 trust，该数组由信任对 trust[i] = [a, b] 组成，表示标记为 a 的人信任标记为 b 的人。 如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的标记。否则，返回 -1。 示例 1： 输入：N = 2, trust = [[1,2]] 输出：2 示例 2： 输入：N = 3, trust = [[1,3],[2,3]] 输出：3 示例 3： 输入：N = 3, trust = [[1,3],[2,3],[3,1]] 输出：-1 示例 4： 输入：N = 3, trust = [[1,2],[2,3]] 输出：-1 示例 5： 输入：N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]] 输出：3 提示： 1 trust.length trust[i] 是完全不同的 trust[i][0] != trust[i][1] 1 解题方案 思路 - 时间复杂度: O(N) - 空间复杂度: O(N) 利用trustedMap来存储“被信任者”的列表，数组下标代表村民的“标记”，数组元素的值代表“被多少人信任”。 利用trustOtherMap来存储“村民信任列表”，数组下标代表村民的“标记”，数组元素的值代表该村民“信任几个人”。 根据题目，每个人（除了小镇法官外）都信任小镇的法官。所以trustedMap中值为N-1的那个元素下标即是法官；但是小镇的法官不相信任何人。所以上一步得到的标记所在trustOtherMap的值一定是空。 执行用时 :136 ms, 在所有 JavaScript 提交中击败了95.77%的用户 内存消耗 :43.4 MB, 在所有 JavaScript 提交中击败了68.00%的用户 代码： /** * @param {number} N * @param {number[][]} trust * @return {number} */ var findJudge = function(N, trust) { let trustedMap = [] let trustOtherMap = [] if (N === 1 && trust.length === 0) { return 1 } trust.forEach(([person, trustedPerson]) => { if (trustedMap[trustedPerson]) { trustedMap[trustedPerson]++ } else { trustedMap[trustedPerson] = 1 } if (trustOtherMap[person]) { trustOtherMap[person]++ } else { trustOtherMap[person] = 1 } }) const trustedPerson = trustedMap.findIndex(i => i === (N - 1)) if (trustedPerson !== -1 && !trustOtherMap[trustedPerson]) { return trustedPerson } else { return -1 } }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"1130._Minimum_Cost_Tree_From_Leaf_Values.html":{"url":"1130._Minimum_Cost_Tree_From_Leaf_Values.html","title":"1130 Minimum Cost Tree From Leaf Values","keywords":"","body":"1130. Minimum Cost Tree From Leaf Values 难度: Medium 刷题内容 原题连接 https://leetcode-cn.com/problems/minimum-cost-tree-from-leaf-values/ 内容描述 给你一个正整数数组 arr，考虑所有满足以下条件的二叉树： 每个节点都有 0 个或是 2 个子节点。 数组 arr 中的值与树的中序遍历中每个叶节点的值一一对应。（知识回顾：如果一个节点有 0 个子节点，那么该节点为叶节点。） 每个非叶节点的值等于其左子树和右子树中叶节点的最大值的乘积。 在所有这样的二叉树中，返回每个非叶节点的值的最小可能总和。这个和的值是一个 32 位整数。 示例 1： 输入：arr = [6,2,4] 输出：32 解释： 有两种可能的树，第一种的非叶节点的总和为 36，第二种非叶节点的总和为 32。 24 24 / \\ / \\ 12 4 6 8 / \\ / \\ 6 2 2 4 提示： 2 1 答案保证是一个 32 位带符号整数，即小于 2^31。 解题方案 思路 - 时间复杂度: O(N) - 空间复杂度: O(N) 执行用时 :60 ms, 在所有 javascript 提交中击败了92.86%的用户 内存消耗 :33.5 MB, 在所有 javascript 提交中击败了100.00%的用户 代码： /** * @param {number[]} arr * @return {number} */ var mctFromLeafValues = function(arr) { if (!arr.length || arr.length { while (stack[0] 2) { res += stack.shift() * stack[0] } return res; }; 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2021-01-02 12:23:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}